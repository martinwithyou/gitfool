<template>
  <div class="echart_demo">
   <p>什么git,分布式版本控制系统，它是linux(全球比较大的操作系统)</p>
   <p>unix(操作系统之间区别)</p>
   <p>linux创始人，花两周时间使用C语言编写工具git</p>
   <p>在git窗口里面，都可以写linux</p>
   
   <p>版本控制系统的优势</p>
   <p>能够详细记录版本信息</p>
   <p>备份文件</p>
   <p>记录历史，多端共享，团队协作，回到过去</p>
   <p>分布式，集中式</p>
   <p>集中式的代码管理系统，代码管理必须联网，而且处理速率没有GIT快</p>
   
   <h1>git 分布式</h1>
   <p>分布式的处理特点</p>
   <p>每个人，每个库，都是一个单独的仓库，在自己的 仓库中，查看历史版本的记录与查看</p>
   <p>git push origin master</p>
   <p>git pull origin master</p>
   <p>git 处理速度更快（git 是按照数据处理的）</p>
   <p>其他区别，自己考虑</p>
   
   <h1>Linux</h1>
   <h1>ls 查看当前目录下的所有文件, -l查看详细信息， -a查看visiable信息</h1>
   <h1>clear清屏</h1>
   <h1>cd 目录切换</h1>
   <h1>cd ../返回上级目录</h1>
   <h1>cd ./返回当前目录</h1>
   <h1>cd /返回根目录</h1>
   <h1>cd xxx 进入指定文件夹</h1>
   <h1>cd E: 进入指定磁盘</h1>
   <h1>创建文件夹mkdir</h1>
   <h1>touch 创建文件，在电脑隐藏文件后缀名的时候，我们也不至于创于1.txt.txt的文件</h1>
   <h1>vi 向指定文件中插入内容，写入文件  vi 1.txt</h1>
   <p>首先进入命令窗口模式， 先按i，进入内容模式，esc+:+wq("保存并退出")</p>
   <p>按q!,强制退出</p>
   <p>echo xxx>1.txt,把xxx内容放到1.txt文件中，如果没有这个文件他会创建这个文件（新内容会替换与哪有内容）</p>
   <p>echo xxx>>1.txt,追加内容</p>
   <p>cat 查看文件里面里面的内容</p>
   <p>cp 拷贝文件</p>
   <p>rm 删除</p>
   <p> -r 递归删除（把后代文件里面的子集都删除）</p>
   <p>-f 强制删除 </p>
   <p>一旦删除掉后，没有办法回复回来</p>
   <h1>安装完成后，先配置一下基础信息，git config</h1>
   <h1>git config user.name,config user.email，记录是谁提交德代码</h1>
   <h1>git 是分布式，每个客户端都是一个独立德git库</h1>
   <h1>git库分为3个区</h1>
   <h1>工作区，暂存区，历史区，工作区可以看见，暂存区，历史区都是以.git保存起来</h1>
   <h1>创建本地仓库  git init,有这个.git文件的叫git 项目 ，暂存区和历史区德内容都存在本地</h1>
   <h1>工作区德内容，提交到暂存区， git add .(所有改动全部提交)</h1>
   <h1> git add -u 修改和删除的，不包含新增的</h1>
   <h1>git add -A .和u相结合</h1>
   <h1>git commit -m "bug fixed"</h1>
   <h1> git status,红色的在工作区中还没有提交到暂存区</h1>
   <h1>绿色的是在暂存区中还没有提交到历史区 </h1>
   <h1>git commit  -m "bug fixed" 暂存区内容提交到历史区里面</h1>
   <h1>git commit -a-m'xxxxxx',将提交到暂存区，暂存到历史区的内容一起操作（这种方式只适合与修改，至少提交过一次修改，对于刚刚创建的文件，是不允许这样的操作）</h1>
   <h1>root-commit,第一次提交到仓库，此时我们仓库中没有任何的分支，哪怕是master,就不会存在分支切换，当前仓库不完整，一个完整工作流走一遍才算完整</h1>
    
    <h1>gitignore文件里面，写什么，文件里面忽略什么文件</h1>
    <h1>.idea, node_modules(之所以忽略提交，是因为内容太多了)，bower_compent DS_Store</h1>
    <h1>从工作区提交到暂存区，还是从暂存区提交到历史区，都有备份</h1> 
    <h1>git log 查看历史提交记录（只能查看提交前的版本号）</h1>
    <h1>git reflog 查看历史提交记录（有历史版本回滚）</h1>
    <h1>git rm --cached . -r(把文件从暂存区撤回，不管暂存区的内容是否提交到历史版本，还是不管你第几次提交到暂存区)</h1>
    <h1>这种方法太暴力了，用的比较少</h1>
    <h1>git checkout .(把暂存区内容撤回工作区，覆盖现有工作区内容，内容无法找回)</h1>
    <h1>用上一个暂存区内容覆盖现有工作区的内容，只能限制当前代码没有提交，回退上一次提交的内容，如果当前这一次也提交了，暂存区和工作区一样，回滚回来解决不了问题</h1>
    <h1>git reset HEAD ,git checkout.</h1>
    <h1>第一步在暂存区中，回滚到上一次暂存区中记录的内容，把最新暂存区的内容回滚到工作区</h1>
    <h1>工作区和暂存区差异，git diff</h1>
    <h1>工作区，历史区， git diff master</h1>
    <h1>暂存区，历史区，git diff --cached</h1>
    <h1>查看少量代码，大量代码看可视化页面，gitlab</h1>
    <h1>历史区回滚 git reset --hard "版本号"</h1>
    <h1>当我们回归到某一个历史版本之后，暂存区域和工作区域的内容，都会被这个版本所代替</h1>
    
    <h1>git 协作开发模式</h1>
    <h1>存储所有人的代码和版本信息</h1>
    <h1>团队协作开发，开发流程还是有所区别的</h1>
    <p>创建中央仓库，团队技术leader,或者指派的人文成的，初始化文件</p>
    <p>中央仓库github,github私有的，自己公司的git服务平台，自己公司的服务器</p>
    <p>github 创建远程中央仓库，创建完成后会生成一个远程地址</p>
    <p>把项目中一下基础的信息提交到远程从仓库，把新增加的信息提交到本地历史仓库中，让本地仓库和远程仓库保持联系，把本地仓库同步到远程仓库</p>
     <p>
     	让本地仓库和远程仓库保持关联，git remote add origin 远程仓库地址
     	git remote rm "名字"
     	git remote -v
     	让本地历史区,和远程仓库信息保持关联
     	git push origin master,本地推送到远端
     	git pull origin master 远端拉倒本地
     	无论pull,push ,都是同步信息的过程
     </p>
     <p>
     	当然我们创建好了远程仓库后，可以直接git clone 仓库地址，把远程仓库地址，
     	相当于在本地创建了一个仓库，
     	也让这个仓库和远程仓库保持连接
     	也把远程仓库现有 的内容克容到本地
     </p>
  </div>
</template>
